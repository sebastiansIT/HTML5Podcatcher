/** This modul contains functions load informations and files from the internet via Fetch API.

    @module podcatcher/web/fetch
    @author Sebastian Spautz [sebastian@human-injection.de]
    @requires module:podcatcher/web
    @requires module:podcatcher/utils/logging
    @license Copyright 2019, 2020 Sebastian Spautz

    This file is part of "HTML5 Podcatcher".

    "HTML5 Podcatcher" is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    any later version.

    "HTML5 Podcatcher" is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see http://www.gnu.org/licenses/.
*/

/* global fetch, ReadableStream */

import WebAccessProvider from './web.js'
import { Logger } from '../utils/logging.js'

/** Logger.
  * @constant {module:podcatcher/utils/logging.Logger}
  */
const LOGGER = new Logger('Web/Fetch')

/**
 * Implements methods to access the internet based on fetch API.
 * @augments module:podcatcher/web~WebAccessProvider
 */
class FetchWebAccessProvider extends WebAccessProvider {
  constructor (sopProxyPattern) {
    super(sopProxyPattern)
    /**
     * A map maps the abort controller for fetch requests to the URLs of downloads.
     * @private
     * @type {external:Map<string, external:AbortController>}
    */
    this._abortControllerList = new Map()
  }

  downloadXML (url) {
    const fetchViaProxy = function (error) {
      if (this.sopProxyPattern) {
        // insert URL into pattern and try again
        const proxyUrl = this.sopProxyPattern.replace('$url$', url)
        LOGGER.info(`Direct download failed. Try proxy: ${proxyUrl}`)
        return fetch(proxyUrl)
          .then(extractBodyTextFromResponse)
          .catch((error) => {
            LOGGER.error(`Can't download XML ${proxyUrl}: ${error.message}`)
            throw error
          })
      } else {
        LOGGER.error(`Can't download XML ${url}: ${error.message}`)
        throw error
      }
    }.bind(this)

    return fetch(url)
      .then(extractBodyTextFromResponse, fetchViaProxy)
      .then((text) => parseXmlFromText(text, url))
      .then((xmlDoc) => {
        LOGGER.debug(`Download of ${url} finished`)
        return xmlDoc
      })
  }

  downloadArrayBuffer (url, onProgressCallback) {
    this.checkUrlParameter(url)
    this.checkProgressCallbackParameter(onProgressCallback)

    if (this._abortControllerList.has(url)) {
      return Promise.reject(new Error(`There is already an active download for ${url}.`))
    }
    const abortController = new AbortController()
    this._abortControllerList.set(url, abortController)

    const fetchViaProxy = (error) => {
      if (this.sopProxyPattern) {
        // insert URL into pattern and try again
        const proxyUrl = this.sopProxyPattern.replace('$url$', url)
        LOGGER.info(`Direct download failed. Try proxy: ${proxyUrl}`)
        return fetch(proxyUrl, { signal: abortController.signal })
          .then((response) => sendProgressEvents(response, onProgressCallback))
          .catch((error) => {
            LOGGER.error(`Can't download binary file ${proxyUrl}: ${error.message}`)
            throw error
          })
      } else {
        LOGGER.error(`Can't download binary file ${url}: ${error.message}`)
        throw error
      }
    }

    return fetch(url, { signal: abortController.signal })
      .then((response) => sendProgressEvents(response, onProgressCallback), fetchViaProxy)
      .then((response) => response.arrayBuffer())
      .then((arrayBuffer) => {
        LOGGER.debug(`Download of ${url} finished`)
        return arrayBuffer
      })
      .finally(() => this._abortControllerList.delete(url))
  }

  abort (url) {
    if (this._abortControllerList.has(url)) {
      this._abortControllerList.get(url).abort()
    } else {
      throw new Error(`No Download to abort available for URL ${url}`)
    }
  }
}

/**
  * Check if the response is OK and returns the content from the body if it so.
  * @private
  * @param {external:Response} response - The respone to a HTTP request.
  * @returns {external:String} The text of a HTTP response.
  * @throws {external:Error} Throws an error if the response isn't OK.
  */
function extractBodyTextFromResponse (response) {
  if (response.ok) {
    return response.text()
  } else {
    throw new Error(`${response.status}: ${response.statusText}`)
  }
}

/**
  * Check if the Response is OK and returns a new response generated by a
  * reader from the fetched response. For each chunk of the reader progress
  * informations are send to the UI.
  * @private
  * @param {external:Response} response - The respone to a HTTP request.
  * @param {module:podcatcher/web~downloadProgressCallback} onProgressCallback - A callback function to send progress informations.
  * @returns {external:Response} A new Response with the same body content.
  * @throws {external:Error} Throws an error if the response isn't OK or a
  * error occured while handling the Stream.
  */
function sendProgressEvents (response, onProgressCallback) {
  if (!response.ok) {
    throw new Error(`${response.status}: ${response.statusText}`)
  }
  // Following Code is inspired by https://github.com/AnthumChris/fetch-progress-indicators/blob/master/fetch-basic/supported-browser.js
  const contentLength = response.headers.get('content-length')
  let fileSizeTotalBytes
  let approximated = false
  if (!contentLength) {
    LOGGER.info(`No content length available in response to ${response.url}`)
    fileSizeTotalBytes = '150000000' // approximate 150MB
    approximated = true
  } else {
    fileSizeTotalBytes = parseInt(contentLength, 10)
  }
  let loadedBytes = 0

  return new Response(
    // TODO refactor this (and understand better whats going on when aborting a request)
    new ReadableStream({
      start (controller) {
        const read = () => {
          reader.read()
            .then(({ done, value }) => {
              if (done) {
                controller.close()
                return
              }
              loadedBytes += value.byteLength
              if (loadedBytes > fileSizeTotalBytes) {
                fileSizeTotalBytes += 50000000 // approximate additional 50MB file size
                approximated = true
              }
              const percentComplete = loadedBytes / fileSizeTotalBytes
              LOGGER.debug('Download array buffer: ' + (percentComplete * 100).toFixed(2) + '%')
              if (onProgressCallback && typeof onProgressCallback === 'function') {
                onProgressCallback({ loaded: loadedBytes, total: fileSizeTotalBytes, approximated: approximated }, response.url)
              }
              controller.enqueue(value)
              read()
            })
            .catch(error => {
              if (!(error instanceof DOMException && error.name === 'AbortError')) {
                LOGGER.error(`Error downloading File with progress informations: ${error}`)
              }
              controller.error(error)
            })
        }

        const reader = response.body.getReader()
        read()
      }
    })
  )
}

/**
  * Parses the given text as XML.
  * @private
  * @param {external:String} text - The body of a HTTP request.
  * @param {external:String} url - The target URL of the HTTP request.
  * @returns {external:XMLDocument} A XML document.
  * @throws {external:Error} Throws an Error when the response body can't parsed as XML.
  */
function parseXmlFromText (text, url) {
  // TODO DOMParser isn't available in worker context.
  const doc = (new DOMParser()).parseFromString(text, 'application/xml')
  if (doc.documentElement.querySelector('parsererror')) {
    LOGGER.error(`No XML Document found at ${url} instead found [' ${text} ]`)
    throw new Error(`No XML Document found at ${url}`)
  } else {
    return doc
  }
}

export default FetchWebAccessProvider
